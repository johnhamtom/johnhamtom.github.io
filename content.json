{"pages":[],"posts":[{"title":"Hello world","text":"Hello world#include &lt;stdio.h&gt; int main() { printf(&quot;Hello, World!&quot;); return 0; } 每次初学一门编程语言，无论是python ， C 还是 java ，老师总是会教我们先在编译器上输出 “Hello world” , 久而久之 “Hello world” 这句话对于我而言就带有一种特殊的味道 ， 所以在这，我也打算使用 Hello world 来作为我的第一个正式的个人博客的标题，同时这也是我第一次使用markdom来编写文章，这一切，仅仅是一个开始。","link":"/2020/03/21/Hello%20world/"},{"title":"leetcode-算法-35","text":"题目描述：搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5输出: 2示例 2: 输入: [1,3,5,6], 2输出: 1示例 3: 输入: [1,3,5,6], 7输出: 4示例 4: 输入: [1,3,5,6], 0输出: 0 方法一：暴力求解法由题意得到是递增的排序数组故：基本思路为target依次的跟数组的数据比较大小，若遇到相等的或者比target大的（这样说明后面的数据都比target大）返回当前比较的下标，如果都没有符合条件的，则在数组末尾插入数据，返回numsSize。时间复杂度：O(n)–空间复杂度O(1) 1234567int searchInsert(int* nums, int numsSize, int target){ for(int i=0;i&lt;numsSize;i++) { if(target&lt;= nums[i]) return i; } return numsSize;} 方法二：折半查找法利用折半法解决，主要思路：初始化：三个指针，l与h指针指向数组的上下界，m指针指向中间（h+l）/2target跟nums[m]比较大小，比它大就l指针后移，比它小就h指针前移。直到查到target 或者 m指针遍历完target左右的数字发现没有符合条件的。时间复杂度：O(logn)–空间复杂度O(1) --- 123456789101112int searchInsert(int* nums, int numsSize, int target){ int l = 0; int h = numsSize -1; int m; while(h&gt;=l){ m = (h+l)/2; if(nums[m] &lt; target) l = m+1; if(nums[m] &gt; target) h = m-1; if(nums[m] == target) return m; } return l;} 注：转自我写在leetcode的算法题解 链接：https://leetcode-cn.com/problems/search-insert-position/solution/35-sou-suo-cha-ru-wei-zhi-li-yong-zhe-ban-fa-jie-j/ 来源：力扣（LeetCode）","link":"/2020/04/30/leetcode-%E7%AE%97%E6%B3%95-35/"}],"tags":[{"name":"hello world","slug":"hello-world","link":"/tags/hello-world/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"查找","slug":"查找","link":"/tags/%E6%9F%A5%E6%89%BE/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"}]}